import { Command } from "../classes/command";
import { CommandContext } from "../classes/commandContext";
import { ChatData } from "../types";
import { EmbedBuilder } from "@discordjs/builders";
import { AttachmentBuilder, Colors } from "discord.js";

export default class extends Command {
    constructor() {
        super({
            name: "chat_thread",
            staff_only: true,
        })
    }

    override async run(ctx: CommandContext): Promise<any> {
        if(!ctx.is_staff && ctx.client.config.global_user_cooldown && ctx.client.cooldown.has(ctx.interaction.user.id)) return ctx.error({error: "You are currently on cooldown"})
        const message = ctx.interaction.options.getString("message", true)
        const messages = []

        if(ctx.interaction.channel?.isThread()) {
            const data = await ctx.database.query<ChatData>("SELECT * FROM chats WHERE id=$1", [ctx.interaction.channelId]).catch(console.error)
            if(!data?.rowCount) return ctx.error({error: "Unable to find conversation.\nUse this command in a non-thread channel to start a new conversation."})
            if(data.rows[0]!.user_id !== ctx.interaction.user.id) return ctx.error({error: "Only the initial user can use this command in this thread."})

            messages.push(...data.rows[0]!.messages)
            messages.push({
                role: "user",
                content: message
            })

            await ctx.interaction.deferReply()

            const ai_data = await ctx.client.requestChatCompletion(messages, ctx.interaction.user.id)

            if(ctx.client.config.dev) console.log(ai_data)

            if(ctx.client.config.global_user_cooldown) ctx.client.cooldown.set(ctx.interaction.user.id, Date.now(), ctx.client.config.global_user_cooldown)
            const reply = await ctx.interaction.editReply({
                embeds: [
                    new EmbedBuilder({
                        author: {
                            name: "ChatGPT",
                        },
                        description: ai_data.choices[0]?.message.content,
                        color: Colors.Blue,
                        footer: {text: "This text has been generated by OpenAIs GPT-3.5 Model"}
                    })
                ]
            })

            messages.push({
                role: "assistant",
                content: ai_data.choices[0]?.message.content
            })
            
            await ctx.database.query("UPDATE chats SET messages=$2 WHERE id=$1 RETURNING *", [ctx.interaction.channelId, messages]).catch(console.error)

            if(ctx.client.config.dev) {
                const devembed = new EmbedBuilder({
                    title: "Dev",
                    description: `**ID** \`${ai_data.id}\`
                
**Prompt Tokens** ${ai_data.usage.prompt_tokens}
**Completion Tokens** ${ai_data.usage.completion_tokens}
**Total Tokens** ${ai_data.usage.total_tokens}`,
                    color: Colors.Red
                })
                await reply.reply({
                    embeds: [devembed]
                })
            }
            return;
        }

        if(ctx.client.config.generation_parameters?.system_instruction?.length) messages.push({role: "system", content: ctx.client.config.generation_parameters?.system_instruction})

        messages.push({
            role: "user",
            content: message
        })

        const reply = await ctx.interaction.reply({
            embeds: [
                new EmbedBuilder({
                    author: {
                        name: ctx.interaction.user.tag,
                        icon_url: ctx.interaction.user.displayAvatarURL()
                    },
                    color: Colors.Blue,
                    description: message
                })
            ],
            fetchReply: true
        })

        const data = await ctx.client.requestChatCompletion(messages, ctx.interaction.user.id)

        if(ctx.client.config.dev) console.log(data)
        if(ctx.client.config.global_user_cooldown) ctx.client.cooldown.set(ctx.interaction.user.id, Date.now(), ctx.client.config.global_user_cooldown)

        const thread = await reply.startThread({
            name: `ChatGPT Chat ${ctx.interaction.user.tag}`,
        }).catch(console.error)

        if(!thread?.id) {
            const description = `${message}\n\n**ChatGPT:**\n${data.choices[0]?.message.content ?? "Hi there"}\n\nUnable to start thread`
            let payload = {}
    
            if(description.length < 4000) {
                const embed = new EmbedBuilder({
                    author: {
                        name: ctx.interaction.user.tag,
                        icon_url: ctx.interaction.user.displayAvatarURL()
                    },
                    description,
                    color: Colors.Green,
                    footer: {text: "This text has been generated by OpenAIs GPT-3.5 Model"}
                })
    
                payload = {embeds: [embed]}
            } else {
                const attachment = new AttachmentBuilder(Buffer.from(`${ctx.interaction.user.tag}:\n${message}\n\nChatGPT:\n${data.choices[0]?.message.content ?? "Hi there"}\n\nThis response has been generated using OpenAIs GPT-3.5 model`), {name: `${data.id}.txt`})
                payload = {
                    content: "Unable to start thread.\nResult attached below",
                    files: [attachment]
                }
            }
            
            await ctx.interaction.editReply(payload)
            return;
        }

        await thread.members.add(ctx.interaction.user)

        const db_save = await ctx.database.query('INSERT INTO chats (id, user_id, messages) VALUES ($1, $2, $3) RETURNING *', [
            thread.id,
            ctx.interaction.user.id,
            [
                ...messages,
                {
                    role: "assistant",
                    content: data.choices[0]?.message.content
                }
            ]
        ]).catch(console.error)

        const thread_msg = await thread.send({
            embeds: [
                new EmbedBuilder({
                    author: {
                        name: "ChatGPT",
                    },
                    description: data.choices[0]?.message.content,
                    color: Colors.Blue,
                    footer: {text: "This text has been generated by OpenAIs GPT-3.5 Model"}
                }),
                new EmbedBuilder({
                    description: !!db_save?.rowCount ? `To create a response to ChatGPTs response use ${await ctx.client.getSlashCommandTag("chat thread")}` : "Unable to save chat for followup",
                    color: !!db_save?.rowCount ? Colors.Green : Colors.Red
                })
            ]
        })

        if(!db_save?.rowCount) thread.setLocked(true)

        if(ctx.client.config.dev) {
            const devembed = new EmbedBuilder({
                title: "Dev",
                description: `**ID** \`${data.id}\`
                
**Prompt Tokens** ${data.usage.prompt_tokens}
**Completion Tokens** ${data.usage.completion_tokens}
**Total Tokens** ${data.usage.total_tokens}`,
                color: Colors.Red
            })
            await thread_msg.reply({
                embeds: [devembed]
            })
        }
    }
}